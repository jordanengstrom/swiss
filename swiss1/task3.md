Rather than parsing command-line arguments ourselves, we can use a third-party library to do this for us. The module github.com/urfave/cli/v2 can be found at https://github.com/urfave/cli. Read through the documentation on this library.

Write a function in main.go called processWrapper that takes in a parameter named c of type *cli.Context and returns an error. In the function, use c.Args().Len() to see if there is exactly one argument passed to our subcommand. If not, use the cli.Exit function to return an error with the message "expected one resource" and the error code 1. If there is one argument, call process with c.Command.Name and c.Args().First(). If this returns a non-nil error, return an error generated by cli.Exit, passing in the text of the non-nil error and the error code 1. If there was no error, print the result and return nil.

We are going to rewrite the main function in main.go. We will instantiate an instance of *cli.App called app and populate its Commands field. This field's type is []*cli.Command. We will create two instances of *cli.Command. These are the fields and their values:

    Command 1:
        Name: "count"
        Usage: "count the bytes in a resource"
        Action: processWrapper
    Command 2:
        Name: "lang"
        Usage: "find the language of a resource"
        Action: processWrapper

After instantiating app, put the following lines into main:

app.ExitErrHandler = func(context *cli.Context, err error) {
    if err != nil {
        fmt.Println(err.Error())
    }
}

(This allows us to capture error messages from redirected output.)

Finally in main, call the Run method on app, passing it os.Args.
